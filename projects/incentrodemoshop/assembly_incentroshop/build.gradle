buildscript {
    dependencies {
        classpath 'com.intershop.build.gradle:plugin-tests:2.8.1'
        classpath 'com.github.groovy-wslite:groovy-wslite:1.1.3'
    }
}

apply plugin: 'ish-assembly'
apply plugin: 'ish-assembly-branding'
apply plugin: 'project-report'
apply plugin: 'jacoco'
apply plugin: 'eclipse'

assembly {
    inheritFrom('com.intershop.assembly:commerce_management_b2x') {
        includeArtifacts type:['deploy-gradle', 'deploy-settings-gradle']
    }
	
	hostTypes {
		share {
            include (
                project(':microservices'),
				project(':responsive_config'),
				project(':responsive_sites')
            ) {
                transitive = false
            }
        }
		microservices {
			include (
                project(':microservices'),
            ) {
                transitive = false
            }
            includeLocal = true

            includeShare = false
            includeCartridges = false            
        }
	}

    cartridges {
        def storefrontCartridges = [
            'app_sf_responsive',
            'app_sf_responsive_cm',
            'app_sf_responsive_b2c',
            'app_sf_responsive_smb',
            'as_responsive',
            'app_sf_responsive_b2b',
            'app_sf_responsive_costcenter',
            'as_responsive_b2b',
			'app_sf_responsive_gdpr'
        ]
        include(*(storefrontCartridges.collect { project(":$it") }), in:[development, test, production])

        def initCartridges = [
            'demo_responsive',
            'demo_responsive_catalog',
            'demo_responsive_content',
            'demo_responsive_search',
            'demo_responsive_b2b',
            'demo_responsive_ocst'
        ]
        include (*(initCartridges.collect { project(":$it") }), in: init)

        def developerCartridges = [
           'dev_storefront'
        ]
        include (*(developerCartridges.collect { project(":$it") }), in: development)

        def testCartridges = [
            'app_sf_responsive_test',
            'app_sf_responsive_b2b_test'
        ]
        include (*(testCartridges.collect { project(":$it") }), in:[development, test])

        order = listFromAssembly('com.intershop.assembly:commerce_management_b2x') + storefrontCartridges + initCartridges + developerCartridges + testCartridges
    }

    extraAttributes = [
            'productName': 'Intershop 7',
            'copyrightOwner': 'Intershop Communications AG',
            'copyrightFrom': '2005'
        ]
}

assemblyBuild {
    database {
        inherit('com.intershop.assembly:commerce_management_b2x')
        initCartridges = [
            'app_sf_responsive',
            'demo_responsive',
            'demo_responsive_catalog',
            'demo_responsive_content',
            'demo_responsive_search',
            'demo_responsive_b2b',
            'demo_responsive_ocst'
        ]
    }
}

dependencies {
    testCompile 'com.intershop.build.gradle:ish-common:2.11.9'
    testCompile "com.intershop.deployment:ish-assembly-test"

    // selenium web drivers
    remoteTestCompile "org.seleniumhq.selenium:selenium-support:2.47.2"
	remoteTestCompile "org.seleniumhq.selenium:selenium-chrome-driver:2.47.2"
	remoteTestCompile ("com.codeborne:phantomjsdriver:1.2.1") {
		transitive = false
	}
	
	remoteTestCompile "org.codehaus.groovy.modules.http-builder:http-builder:0.5.0"
	remoteTestCompile "org.hamcrest:hamcrest-all:1.3"
	
}

ishUnitTest {
    jvmArgs '-DEmbeddedServerRule.loadAllCartridges=true'
}

gebConfiguration {
    systemProperties['baseURL_https'] = "https://${remoteTest.env.hostName}:${remoteTest.env.webserverHttpsPort}"
    webDrivers {
        phantomJsDriver {
            environments {
                phantomJsPC {check=true}
            }
            download {
                linux {
                    url = 'https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-linux-x86_64.tar.bz2'
                    archiveType = 'tar'
                    webDriverDir = 'phantomjs-2.1.1-linux-x86_64'
                    webDriverExec = 'bin/phantomjs'
                }
                windows {                    
                    url = 'https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-windows.zip'
                    archiveType = 'zip'
                    webDriverDir = 'phantomjs-2.1.1-windows'
                    webDriverExec = 'bin/phantomjs.exe'
                }
            }
        }

        chromeDriver {
            environments {
                chromePC
                chromeTablet
            }

            download {
                linux {
                    url = 'http://chromedriver.storage.googleapis.com/2.40/chromedriver_linux64.zip'
                    archiveType = 'zip'
                    webDriverExec = 'chromedriver'
                }
                windows {
                    url = 'http://chromedriver.storage.googleapis.com/2.40/chromedriver_win32.zip'
                    archiveType = 'zip'
                    webDriverExec = 'chromedriver.exe'
                }
            }
        }
    }
}

/***********************************************************************************************************************
 *
 * Currently the gradle tools do not provide a task for rebuilding the search indexes. But these it required for inSPIRED
 * storefront tests. So this is workaround for solving this problem temporary.
 *
 ***********************************************************************************************************************/
buildscript {
    dependencies {
        classpath 'com.github.groovy-wslite:groovy-wslite:1.+'
    }
}

task 'buildSearchIndex' {
    def hostName    = remoteTest.env.hostName
    def port        = remoteTest.env.webserverPort
    def adminUser   = remoteTest.env.adminUser?: 'admin'
    def adminPwd    = remoteTest.env.adminPwd?:  '!InterShop00!'

    def url = "http://${hostName}:${port}/INTERSHOP/rest/BOS/SMC/-/domains/SLDSystem/jobs"

    def jobStatus = { job ->
        def client = new wslite.rest.RESTClient("${url}/${job}")
        client.authorization = new wslite.http.auth.HTTPBasicAuthorization(adminUser, adminPwd)
        def response = client.get()
        return response.json.status
    }

    def triggerJob = {job ->
        def client = new wslite.rest.RESTClient("${url}/${job}")
        client.authorization = new wslite.http.auth.HTTPBasicAuthorization(adminUser, adminPwd)

        try {
			logger.quiet("Start Job: ${job}")
            def responseTrigger = client.put() {
                json type: 'job', status: 'RUNNING'
            }
            logger.debug("response for triggered job: ${responseTrigger}")
        } catch(wslite.http.HTTPClientException ex) {
            throw new GradleException("The job ${job} could not be triggered", ex)
        }

        //wait to let the job executor start the job
        sleep 5000
        
        def maxTry = 240
        def jobState = jobStatus(job)
         
        while (maxTry-- > 0 && "RUNNING" == (jobState = jobStatus(job))) {
       
			logger.info("status of job is ${jobState}. status checks left: ${maxTry}")
            sleep 5000
        }
        logger.quiet("Status: ${jobState}")
     
        if(jobState == "RUNNING") {
            throw new GradleException("Job ${job} was triggered, but is still 'RUNNING' after 20 minutes.")
        }
    }

    doFirst {
		waitForSocket(remoteTest.env.hostName, remoteTest.env.webserverPort, 180)

        triggerJob("Rebuild%20Search%20Indexes")
        triggerJob("Update%20Product%20Assignments")
        triggerJob("Rebuild%20Search%20Indexes")
    }
}

def checkSocket(String hostname, String port) {
    try {
        new Socket(hostname, port.toInteger())
        return true 
    } catch (Exception e) {
        logger.quiet("Server was not available on ${hostname} and ${port}")
        return false
    } 
}

def waitForSocket(String hostname, String port, int seconds) {
    while(!checkSocket(hostname, port) && seconds > 0) {
        logger.quiet("Waiting on ${port}")
        Thread.sleep(5000)
        seconds -= 5
    }
}

tasks.each { t ->
    if (t.name ==~ /geb.*Test/) {
        if(!(t.name ==~ /geb.*DriverTest/)){
            t.environment("run_quarantine", remoteTest.env["run_quarantine"])
        }
        t.dependsOn tasks.buildSearchIndex
        t.mustRunAfter tasks.dbinit
        t.mustRunAfter tasks.test
        tasks.publish.mustRunAfter t
    }

    if (t.name != 'clean')  {
        t.mustRunAfter tasks.clean
    }
}

task restTest(type:Test) {  
  outputs.upToDateWhen { false }

  description = "Executes Remote REST tests against a running server"
  group = 'verification'

  testClassesDir = project.file(project.sourceSets.remoteTest.output.classesDir.getAbsolutePath() + '/rest')
  classpath = project.sourceSets.remoteTest.runtimeClasspath

  // taking over some environemnt variables into the spec as system property
  ['hostName', 
   'webserverPort',
   'webserverHttpsPort'].each 
  { key -> 
       systemProperty key, remoteTest.env[key]
  }
       
  reports {
    html.destination = project.reporting.file("remote/rest")
    junitXml.destination = project.file("${project.buildDir}/test-results/rest")    
  }
}

tasks.remoteTest.dependsOn tasks.restTest
  
tasks.buildSearchIndex.mustRunAfter tasks.startWebserver, tasks.startNodemanager
// Rest integration tests must be started when the server is really available
tasks.restTest.mustRunAfter tasks.buildSearchIndex

tasks.stopNodemanager.mustRunAfter tasks.restTest
tasks.stopWebserver.mustRunAfter tasks.restTest

tasks.restTest.finalizedBy tasks.stopNodemanager
tasks.restTest.finalizedBy tasks.stopWebserver

tasks.publish.mustRunAfter tasks.remoteTest, tasks.stopWebserver, tasks.stopNodemanager
tasks.startNodemanager.mustRunAfter tasks.test, tasks.ishUnitTest, tasks.dbinit
tasks.startWebserver.mustRunAfter tasks.test, tasks.ishUnitTest, tasks.dbinit

tasks.test.mustRunAfter tasks.clean